mnist -> data set de imagenes de 28x28 lo pasaremos un vecto, (0,0), (0,28) -> poner la foto recta, tendrá 784 dimensiones.


X = 784

la salida serán 10 números por que mnisk devuelve valores del 0 al 9.

las dimensiones de cada matriz de pesos, será una matrix de alto de 784 y de ancho (no definimos nosotros, 1000 en este caso), la salida será un vector de 1000 lo que hará que la B será un vector de 1000.

W2 = 1000 (por que me vienen 1000) X 100 (lo he elegido yo, me lo puede inventar)

Z3 será 100 x 10 por que vienen 3 y mnist solo devuelve 10 números, osea 100X10


784*1
784*1000
1000*1
1000*100
100*10
10*1


todos random,

pesos del 0 al 1 (np.zeroslike)

bias con 0, por que se irán adaptando


1- inicializar modelo, le pasos las dimensiones y inicializo los pesos random.
w1,w2,w3 b1,b2,b3 inicializar estás matrices

2- definir la función de activación (sigmoid y relu (en python)), probamos que funcionen bien.

3- definir el forward (que sería el output) 


layers abstracta con metodo forward

- input implementar forward devuelve la x
- activation implementa forward -> devuelve la relu(x)
- Capa densa (Dense) forward -> (x@w) + b 


def ReLU(x):
    return x * (x > 0),
    return np.maximum(x,0)

Como multiplicar una matriz -> numpu.matmul las multiplicaciones se expresan con @ no con *



7-02-2024
______________________________________________________________________________________


Cómo tratar el output de la ia.

Crear función fuera del código, la función de coste: (y_pred - y-real)²

Eliminar, la última relu que tenemos implementada en el modelo.


Función de coste: Te dice como van de bien los pesos que hemos asignado, para ver la pendiente que sigue con los pesos actuales, se tendría hacer la derivada de la función de coste, respecto a las propiedades, (el gradiente de la función de coste)


C0 = error, lo utilizaré para mejorar los pesos de la primera capa.

Depende de la n3 y de la 'y'.

n3 = n2 @ w2 + b2

D' = Derivada

N3 = y_pred

/ -> respecto de 

D'C0 / D'W3 =  D'(y_pred(n3) - y-real)² / D'w3 = (D'(n3-1)² / D'N3) * D'N3/D'W3


2(n3-y) * n2

dW3 = 2(N3-y)N2


D'C0 / D'B3 = D'B3 = 2(N3-y) * 1

Todo lo de arriba es para calcular lo ultimo W3 y B3. Pero tenemos que propagar el error hacía hacer (w2,b2 etc)

